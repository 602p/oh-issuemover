{"status": "resolved", "priority": "feature", "title": "Migrate all bug importers to Twisted", "milestone": "0.11.11", "superceder": "", "nosylist": ["paulproteus, pythonian4000"], "assigned": "pythonian4000", "waitingon": "", "keywords": [], "id": "260", "files": [], "history": [{"message": "The old-style Launchpad importer is disabled, so close-enough. I guess I will\ntake this moment to mark those bugs as looks_closed for now, so that they do not\nshow up in the web interface.\n\n<a href=\"issue367\">issue367</a> can live on in its separate life.\n   \n", "author": "paulproteus"}, {"message": "This is a release goal for 0.11.11, I'm happy to say.\n   \n", "author": "paulproteus"}, {"message": "See <a href=\"http://piratepad.net/async-bug-importer\">http://piratepad.net/async-bug-importer</a> for planning of the architecture and\nlayout of the asynchronous importer.\n   \n", "author": "pythonian4000"}, {"message": "I'm splitting this up into one issue for each importer.\n   \n", "author": "pythonian4000"}, {"message": "Hmm, this is harder than I thought... I'm just going \nto ad-lib some thoughts on this here.\n\nThe Twistedification of the DIAs works nicely because \nyou have the following flow:\n- User creates DIAs manually.\n- This also creates a watch file.\n- Watcher sees watch file and wakes up twist command.\n- Twist command grabs URLs for each DIA.\n- Twist command grabs data from each URL and passes it \nto the handler.\n- When all URLs for a DIA have been grabbed, the DIA \nis marked as finished.\n\nThis works nicely because each DIA corresponds to a \nsingle query, even though one query can have multiple \nURLs). As such, you have a single \"layer\" of classes \ninteracting with the Twisted reactor.\n\n(Asheesh, as you wrote this code, feel free to correct \nmy understanding!)\n\nIn the bug importer case, things are more complex: a \nparticular tracker may have several query URLs that it \nwants monitored. Unlike the DIA case, these query URLs \nare not necessarily related, so you would either need \na one-to-many TQA (Tracker Query Attempt) model or you \nwould need one TQA per URL.\n\nThen, for some query URLs you have fetched all the bug \ndata in one go (e.g. Bugzilla or Google Issues) so you \nare now ready to pass it on to be divided and put into \nBugs. But in other cases, you now only have a list of \nbugs to get, and so you now need to create a whole lot \nmore URLs to be grabbed.\n\nThe main problem I am trying to work out is tying a \nparticular URL or TQA to a particular class. In the \nDIA case a hard-coded dict of two-letter codes is used \nto identify the source of a DIA. But for the bug \nimporter, while the tracker types available won't \nchange often, the actual individual trackers will, and \neach individual tracker ends up with its own class sub-\nclassed from one of the generic tracker types. In \naddition, if we want to be able to add individual \ntrackers via a web interface then these classes are \ngenerated on-the-fly, so we can't just use the \nclass \"path\" (e.g. \nmysite.customs.bugtrackers.google.MelangeGoogleTracker)\n.\n\nI'm not sure whether it would be better to have an \nindividual TQA for a project (so trying to attack \nmultiple distinct URLs to it) or an individual TQA for \na Bug (so one URL for each TQA). The latter would \npossibly also work for updating the bugs we have \nstored that are not in the tracker queries any longer.\n\nAnother part is actually generating the TQAs in the \nfirst place. I was thinking maybe having a command run \nhourly, that would check some timestamp for each \nclass, and create the initial TQAs (the ones grabbing \nthe lists of bugs, or all bug data for a query URL), \nand then create the watchfile that the twist command \nis triggered from. In the case of the auto-generated \nclasses, the Timestamp could be tied to a string in \nthe model that stores the data for generating the \nclass.\n\nThis command could also run a Django query grabbing \nall stale Bugs and creating TQAs for them, though this \nwould require some way of identifying the source of \nthe Bug; currently the Bugs are fetched inside the \nrelevant individual tracker class by looking for the \nindividual tracker's base URL in the Bug's canonical \nURL, but here the Bugs would be fetched first and then \nthe correct individual tracker class would need to be \nfetched. This could *possibly* be done by a reverse \nlookup of the one above, but is it possible to search \nthrough a set of strings looking for the one that is \npresent inside a particular string?\n\nI'm sure there was more, but I'll add it later when I \nremember what it was.\n\n&lt;/braindump&gt;\n   \n", "author": "pythonian4000"}, {"message": "Gonna have a crack at this during my flight to Belgium.\n   \n", "author": "pythonian4000"}, {"message": "It would be really nice to get this done in 0.11.03!\n   \n", "author": "pythonian4000"}, {"message": "<a href=\"https://openhatch.org/bugs/issue132\">https://openhatch.org/bugs/issue132</a> is not about Twisted but it will be resolved\nonce both the Trac and Roundup importers are migrated.\n   \n", "author": "pythonian4000"}, {"message": "This is a tracking bug following the progress of getting all the current bug\nimporters migrated to importing bugs asynchronously via Twisted.\n\n&lt;thinking&gt;\nIn all likelihood the customs_daily_tasks management script will be integrated\ninto customs_twisted so both profile imports and bug imports are handled by the\none Twisted reactor; both of them rely on network calls and it makes sense to\nmanage all out network imports in one place.\n&lt;/thinking&gt;\n   \n", "author": "pythonian4000"}]}