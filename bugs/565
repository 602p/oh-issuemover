{"status": "chatting", "priority": "bug", "title": "Use cache-control headers so that anonymous pages are always cached by reverse proxies", "milestone": "later", "superceder": "", "nosylist": ["paulproteus"], "assigned": "", "waitingon": "", "keywords": ["performance"], "id": "565", "files": [], "history": [{"message": "Not done\n   \n", "author": "paulproteus"}, {"message": "Right now, we rely on Django's caching for performance. We use the django-\nstaticgenerator app to do some ad-hoc extra caching.\n\nThere are some pages which are accessed by users who are logged-in that we should \nbe able to cache. Right now, if a request gets passed all the way to Django, we \nhave Django generate the results.\n\nBut that is not the only way to do it. Instead, Django could simply indicate that \nthe request has not been modified in the time since it was last cached.\n\nThe way this would work is:\n\n* First time: Client connects to our transparent proxy and does a GET. Proxy has \nno data in the cache, so it asks the Django code. Our Django code returns the \nfull response, as well as this HTTP header: \"Cache-control: public, s-maxage=0, \nproxy-revalidate\".\n\n* Second time: Client connects to our transprent proxy and does a GET. Proxy has \nthe page in its cache. Because the Django app said 'proxy-revalidate', the proxy \nmust always ask the server if the cached version is valid. The proxy does the \nGET, but also adds a header: \"If-Modified-Since:\" plus the time that it did the \nGET that caused the data to be in the cache. Django app looks at all the models \nthat it would have used, and if none were modified since the If-Modified-Since \ntime, it says, \"304 Not Modified\". This is way faster than actually generating \nthe page.\n\nThanks to Michael Stone for this concept.\n   \n", "author": "paulproteus"}]}