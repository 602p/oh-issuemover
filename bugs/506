{"status": "chatting", "priority": "feature", "title": "New way of marking Mozilla bugs as being bitesize", "milestone": "later", "superceder": "", "nosylist": ["jdm, jessica, paulproteus"], "assigned": "paulproteus", "waitingon": "", "keywords": [], "id": "506", "files": [{"url": "http://openhatch.org/bugs/file378/diff.txt", "author": "jessica"}], "history": [{"message": "Will deal with the mentorship part separately. Moving this into 'later' since\n0.11.11 is due today.\n   \n", "author": "paulproteus"}, {"message": "I'm going to separate this into two tickets: One for the \"Bug has mentors\navailable\", and another for \"This is bitesized.\"\n   \n", "author": "paulproteus"}, {"message": "We should make sure this gets done during 0.11.11!\n   \n", "author": "paulproteus"}, {"message": "On Thu, 4 Aug 2011, Jessica Ledbetter wrote:\n\n&gt; I tried running tests but don't think I'm running the right ones.\n&gt;\n&gt; ./bin/mysite customs_debugger help\n&gt; from\n&gt; <a href=\"https://openhatch.org/wiki/Bug_tracker_import_code/adding_a_bug_tracker\">https://openhatch.org/wiki/Bug_tracker_import_code/adding_a_bug_tracker</a>\n&gt;\n&gt; shows how to list old bugs, closed bugs, but not \"stuff you just added\" like a\n&gt; diff. I have a bug that should show up before and after the change and a bug\n&gt; that will be new after the change. I test by manually typing it in the search\n&gt; after running:\n&gt;\n&gt; ./bin/mysite customs_daily_tasks\n\nThat is running the code, not running the test suite.\n\n&gt; But this runs them all. Isn't there a way just to run the one added?\n\nI actually think there is -- read the source of customs_daily_tasks.py. If \nso, it should be visible there.\n\n&gt; Or are you saying that I need to add a test_mozilla (like test_kde) under\n&gt; BugzillaTests in customs/tests.py?\n\nIndeed *this* is what I'm saying. Add a test method called (e.g.)\n\ntest_mozilla_bitesize_bug_detected_correctly()\n\nand then run it with:\n\n./bin/mysite test customs.TheClassNameWhereYouAddedTheMethod.method_name\n\n&gt; Another question after the IRC chat :)\n&gt;\n&gt; What's 'good_for_newcomers' and 'bite_size_tag_name' for? I saw it on the Bug\n&gt; model. You said that when it goes back through that it checks to make sure that\n&gt; it is still bite sized by looking for the text that is assigned to it.\n\nbite_size_tag_name is useless. In fact, I don't see it ever *read* \nanywhere, only written-to. I'm kind of confused.\n\ngood_for_newcomers is displayed in the web UI as \"bitesize\" -- that's the \nimportant field.\n\n&gt; So how to say that it the whiteboard_text could be one or the other?\n&gt;\n&gt; Doesn't seem to be:\n&gt; ret_dict['good_for_newcomers'] = (whiteboard_text == '[good first bug]' or\n&gt; whiteboard_text == '[mentor=')\n\nFor one thing, I would separate this out into multiple lines.\n\nSecond, I think you want:\n\n('good first bug' in whiteboard_text)\n\nnot the == comparison.\n\nSimialr story for the mentor= check.\n\n&gt; It seems to stop at [good first bug] and not get [mentor=\n\nYou could use more parens. But really, here's what I would do:\n\n* Start by making this a few lines long.\n\n* If that doesn't do what you want, write a function like:\n\ndef _mozilla_bug_looks_bitesized(text):\n    if text == '[good_first_bug]':\n      return True\n    # handle more cases...\n    return False # by default\n\nand if *that* doesn't do what you want, play with it in the interpreter.\n   \n", "author": "paulproteus"}, {"message": "Another question after the IRC chat :)\n\nWhat's 'good_for_newcomers' and 'bite_size_tag_name' for? I saw it on the Bug\nmodel. You said that when it goes back through that it checks to make sure that\nit is still bite sized by looking for the text that is assigned to it. \n\nSo how to say that it the whiteboard_text could be one or the other?\n\nDoesn't seem to be:\nret_dict['good_for_newcomers'] = (whiteboard_text == '[good first bug]' or\nwhiteboard_text == '[mentor=')\n\nIt seems to stop at [good first bug] and not get [mentor=\n   \n", "author": "jessica"}, {"message": "On Tue, 2 Aug 2011, Jessica Ledbetter wrote:\n\n&gt; Since I have been wanting to get into the bug tracker code to get \n&gt; Lighthouse in there and I &lt;3 Mozilla, I grabbed this. But my lack of \n&gt; knowledge of the bugtracker code is obvious now :)\n&gt;\n&gt; I thought, \"Oh! I'll do a regexp!\" Works in the browser but when running \n&gt; in the bug tracker code, it doesn't.\n\nMeta-commentary:\n\nIn general, submit patches. It doesn't have to be beautiful git \nformat-patch stuff; just the output of 'git diff' is helpful. Similarly, \nyou could push your work to a Gitorious or Github fork; that would be \nquite helpful too.\n\n&gt; New easy bug url:\n&gt; <a href=\"https://bugzilla.mozilla.org/buglist.cgi?resolution=---;status_whiteboard_type=regexp;query_format=advanced;status_whiteboard=good%20first%20bug\">https://bugzilla.mozilla.org/buglist.cgi?resolution=---;status_whiteboard_type=regexp;query_format=advanced;status_whiteboard=good%20first%20bug</a>|mentor\n&gt;\n&gt; Old new easy bug url:\n&gt; <a href=\"https://bugzilla.mozilla.org/buglist.cgi?resolution=---;status_whiteboard_type=substring;query_format=advanced;status_whiteboard=\">https://bugzilla.mozilla.org/buglist.cgi?resolution=---;status_whiteboard_type=substring;query_format=advanced;status_whiteboard=</a>[good%20first%20bug]\n\nThis seems reasonably good. It does work in the browser!\n\n&gt; I saw some bugs don't have brackets but still are \"good first bug\" so \n&gt; this gets them too.\n\nNice. IMHO that by itself should be a separate commit.\n\n&gt;\n&gt; -----------------Begin Code------------------------------------------\n&gt; def generate_current_bug_xml(self):\n&gt;        queries = {\n&gt;                'Easy bugs':\n&gt;                    '\n&gt; <a href=\"https://bugzilla.mozilla.org/buglist.cgi?resolution=---;status_whiteboard_type=regexp;query_format=advanced;status_whiteboard=good%20first%20bug\">https://bugzilla.mozilla.org/buglist.cgi?resolution=---;status_whiteboard_type=regexp;query_format=advanced;status_whiteboard=good%20first%20bug</a>|mentor\n&gt; ',\n&gt;                #'Documentation bugs':\n&gt;                    #''\n&gt;                }\n&gt;        return self.generate_bug_xml_from_queries(queries)\n&gt;\n&gt;    @staticmethod\n&gt;    def extract_tracker_specific_data(xml_data, ret_dict):\n&gt;        # Make modifications to ret_dict using provided metadata\n&gt;        # Check for the bitesized keyword\n&gt;        whiteboard_text =\n&gt; mysite.customs.bugtrackers.bugzilla.get_tag_text_from_xml(xml_data,\n&gt; 'status_whiteboard')\n&gt;        ret_dict['good_for_newcomers'] = (whiteboard_text == 'good first\n&gt; bug')\n&gt;        ret_dict['bite_size_tag_name'] = 'good first bug'\n&gt;        # Then pass ret_dict back\n&gt;        return ret_dict\n&gt;\n&gt;\n&gt; -----------End Code----------------------\n\nWhat do you mean that it doesn't work in the code?\n\nAlso, FWIW, I would make there be two queries here -- one for the \nwhiteboard good_first_bug, the other for mentor. It's just easier to read \nthat way. Also, it's nice if we don't do a regexp query against their \nBugzilla if possible; those are really slow for them to execute.\n\n&gt; So, can I just say \"All these bugs are good. Just take 'em.\" Or do I have to\n&gt; say that the whiteboard_text will have 'good first bug' or 'mentor' again in\n&gt; extract_tracker_specific_data even though that should be all we have from\n&gt; the 'easy bugs' url?\n\nThe idea is that extract_tracker_specific_data() is called whenever a bug \nis refreshed. So you do have to repeat the whiteboard_text constraint. \nHere's why:\n\n* Day 1: A new bug comes in from the search. It is obviously a good first \nbug.\n\n* Day 2: Nothing happens.\n\n* Day 3: We do our periodic refreshing of bug data. We download the bug \nXML, and we discover that the whiteboard status is still 'good \nfirst bug'. We leave the bug as good_for_newcomers.\n\n* Day 4: Someone at Mozilla realizes that the bug is bad for newcomers and \nremoves the whiteboard status.\n\n* Day 5: We do our periodic refreshing of bug data. We download the bug \nXML, and we discover the whiteboard status is the empty string. We set the \nbug as good_for_newcomers=False.\n\n&gt; I saw this comment, \"It doesn't matter what type of query url\n&gt;    # is stored, since the incorrectly generated method will not be used\n&gt;    # anyway when bt.query_url_type is checked later.\"\n\nOkay, wow, I have *no* idea what that refers to.\n\n/me reads the source...\n\nI don't really understand what that refers to, but I don't think it's \nrelevant here.\n\nWhen you tried things, what exactly \"didn't work\"?\n\n&gt; So maybe that's why?\n&gt;\n&gt; Thank you in advance for the help :) I'm really tired so probably missing\n&gt; something so simple. :)\n\nOne other thing here: I really suggest dealing with issues like this \nthrough the test suite also.\n   \n", "author": "paulproteus"}, {"message": "If the indexer could search for bugs with mentor= in the whiteboard, that would\nbe a great solution. We don't necessarily want to replace the existing search\nfor bugs with \"good first bug\" in the whiteboard, since not everyone in Mozilla\nhas converted to using the new mentored marking yet.\n   \n", "author": "jdm"}, {"message": "There's a new way of marking bugs in Mozilla projects as bitesized. They emailed\nus to say:\n\nWe've recently started a new movement to add\n[<a href=\"mailto:mentor=stringofcharactersthatmaybeanemail@ornot.com\">mentor=stringofcharactersthatmaybeanemail@ornot.com</a>] in the whiteboard of bugs\non bugzilla.mozilla.org that have a mentor associated with them.  It would be\nswell to get them indexed by OpenHatch.\n\nSo we should have a way to show that!\n   \n", "author": "paulproteus"}]}