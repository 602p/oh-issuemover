{"status": "resolved", "priority": "urgent", "title": "Bug objects should know how to refresh themselves", "milestone": "0.11.03", "superceder": "", "nosylist": ["paulproteus, pythonian4000"], "assigned": "paulproteus", "waitingon": "", "keywords": [], "id": "368", "files": [{"url": "http://openhatch.org/bugs/file203/fix_for_patch_0007.patch", "author": "pythonian4000"}, {"url": "http://openhatch.org/bugs/file202/patches.tar.gz", "author": "paulproteus"}], "history": [{"message": "This backend change is pushed now! Thanks Jack for the fix; that was a total\nn00b mistake on my part.\n   \n", "author": "paulproteus"}, {"message": "I'm liking this. Aside from the fact that nearly all of this code will be moved\naround, renamed etc. with the async stuff, I think it's great.\n\nYour patch series is all fine, except for (after applying all patches) line 554\nin search/models.py:\n\nreturn cls(pk=self.bug_tracker_model_pk).create_class_that_can_actually_crawl_bugs()\n\ncls(pk=self.bug_tracker_model_pk) results in an instance of the model class that\nhappens to have the same pk as an existing instance, rather than the actual\nexisting instance as you require. Of course, this isn't a problem because you\nnever save this instance, but there is absolutely no other data in there. Since\nbot existing database tracker models have a manager named \"all_trackers\", the\nmodification to line 554 in the extra patch I uploaded fixes everything.\n\n(On a related note, it's a very weird feeling to be on the other side of a patch\nreview! =D )\n   \n", "author": "pythonian4000"}, {"message": "Hey Jack,\n\nI am running into some issues implementing this, and instead of banging my head\nagainst it for any longer, I thought I'd ask if you could help.\n\nThe final commit in the series is the broken one. Can you give it a look? The\ncommit log message explains what I was trying to do.\n   \n", "author": "paulproteus"}, {"message": "I'm working on this now! And posting to [Devel] about it.\n   \n", "author": "paulproteus"}, {"message": "As part of keeping the Bugs in the database all fresh, we need to be able to get\nall Bug objects that at the current point in time are stale. This was done\npreviously in segments via the tracker class that created and updated those\nBugs, but due to differences in ordering there would always be bugs that were\nfresh by a few seconds and got missed, which now causes Nagios to spam us with\nmessages about stale Bugs.\n\nAs part of the move to asynchronous bug importing, we want to move this query to\nthe Bug model. The issue currently though is that, while we can easily obtain a\nlist of stale Bugs with some simple QuerySet manipulation, there is no way of\nfinding the code that updates them.\n\nA solution to this is to have a ForeignKey in the Bug model that points to the\ndatabase model for the tracker that created it. This would mean that Bug objects\ncould be easily refreshed when stale, and then Nagios would stop complaining all\nthe time (until we move over to the asynchronous system and get a heap of bugs\nthat is!). In the case of trackers that have to be hard-coded (read: NEARLY\nEVERY Bugzilla tracker ~_~ ), once the asynchronous code is set up they will be\nrepresented by a database model as well, which just has a string pointing to the\nhard-coded class. But for now, they can be a small minority not covered in this\nissue.\n\nBelow is the relevant discussion from PiratePad between pythonian4000 and\npaulproteus:\n\nI see this as being in two parts:\n * The code looks for stale tracker queries to update.\n * The code looks for stale bugs to update. &lt;-- but Bug objects do not typically\nknow how to update themselves, iirc &lt;-- and this needs changing, possibly by\nadding a ForeignKey to the tracaker object that created them (since this is the\nonly way Bugs are introduced to the system). but some bugs are created through\nhard-coded classes. I'd be okay with storing those class names as strings, or\nsomething (and there will probably always be some of those for e.g. Bugzilla\ninstances) I do agree there, but I struggle to work out a better way to manage\nthis asynchronously (otherwise we need  to keep the async code individual to\neach specific tracker (subclassing, where possible? (not by my understanding of\nTwisted -- take a look at \"class ProfileImporter\" in\nmysite.customs.profile_importers-- we only override methods as needed, and the\nTwisted callback is usually a bound instance method)\n  * I'm trying to remember my reasoning: If I want to update all stale URLs,\nthis information is stored along with the tracker required to update them. But\nif I want to update all currently stale bugs, I can (without knowing anything\nelse) get a list of all such bugs. But it is tying them to the required subclass\nof a subclass of a general async tracker instance that is the problem,\nespecially if such instances are auto-generated on-the-fly.\n   * make the class_name a string, and try to __import__() and instantiate that\n   * and that doesn't work, try to decode the class string as some sort of hint\nas to how to create it from the database\n   * So some class_name attributes look like \"__TracTracker__,id=13\" (those are\nthe ones you get from the database) and others look like\n'mysite.customs.bugtrackers.bugzillas.MozillaDotOrg' (that's one to instantiate\nfrom code)\n   * downside, it's not then a true foreign key\n    * Can't we just drop Bugzilla support, since this is all its fault anyway? ;P\n    * We could also create a special BugzillaTrackerThatIsHardcoded model, and\nthat could have an attribute for the string form of the class name. Then\nBugzilla trackers that are hard-coded appear in the DB, too, which is good for\nthe UI. But when we *use* them, we know to grab special methods from the code.\n     * I like the above!\n     * So do I!\n      * yay!\n      * There is also a single Google model hard-coded but I believe that is\nbecause it has three tags meaning 'bite-sized'. But if we can work out how to\nstore this in the database then it fixes that.\n       * And we can always do the same thing as Bugzilla for other tracker\ntypes, but Bugzilla is the one that NEEDS it ^_^\n        * precisely. Want to remove this conversation and turn it into a\ndecision, then sprinkle that into the thread above?\n        * Aww, reached indent limit =D\n        * I say do the decisioning and sprinkling first, then remove this later.\n        * kay\n   \n", "author": "pythonian4000"}]}